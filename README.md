
### Overview
Native JNI support for wall clock times in microsecond and nanosecond precision.
This precision comes at the expense of an extra 5ns invocation cost over the build in methods offered by `System.currentTimeMillis()`.

### Building the Project
Run the following command to build the project:

```
mvn clean deploy
```

The build process will generate the following files:

> target/native-time.jar
> target/lib/libnativetime.so

### Benchmarks

Since this is a very small project, it would be overkill to split the banchmarks out into a separate project.
Due to this, benchmarks.jar is not created.

You can run the benchmarks using th exec plugin:

```
mvn exec:exec
```


These results were run on Ubuntu 16.04 LTS Intel Core i7-8550 @ 1.80GHz.


```
Benchmark                                Mode  Cnt   Score   Error  Units
NanoTimeBench.currentTimeMillis        avgt   25  20.396 ± 0.054  ns/op
NanoTimeBench.nanoTime                 avgt   25  20.813 ± 0.935  ns/op
NanoTimeBench.currentTimeMicros        avgt   25  25.900 ± 1.246  ns/op
NanoTimeBench.currentTimeNanos         avgt   25  25.117 ± 1.479  ns/op
```

### See Also

Very useful explanation of the output generated by +PrintCompilation
https://gist.github.com/rednaxelafx/1165804#file_notes.md

#### TODO
 - The native calls do not appear to benefit from JavaCritical optimizations, and in fact appeared to be ever so slightly slower, so have been removed.

See here for more information on JavaCritical:
https://stackoverflow.com/questions/36298111/is-it-possible-to-use-sun-misc-unsafe-to-call-c-functions-without-jni/36309652#36309652

- Bundle the native libraries in the jar.
    src/main/resources/lib/win-x86/<dlls for 32-bit windows>
    src/main/resources/lib/linux-x86/<so for 32-bit linux>
    src/main/resources/lib/linux-x86_64/<so for 64-bit linux>
    src/main/resources/lib/linux-ia64/<so for 64-bit linux on itanium>