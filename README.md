
### Overview
This library basically offers wall clock times in micro and nano second precision at the expense of an extra 5ns invocation cost.

The native calls do not appear to benefit from JavaCritical optimizations.
Next step should be to enable compiler logging to see if/how the JNI calls are optimized.

### TODO
- Banchmarks should be able to run from the command line using the uber jar benchmarks.jar. Currently not working.

### Benchmarks

```
Benchmark                                Mode  Cnt   Score   Error  Units
NativeTimeBench.currentTimeMillis        avgt   25  20.396 ± 0.054  ns/op
NativeTimeBench.nanoTime                 avgt   25  20.813 ± 0.935  ns/op
NativeTimeBench.nativeCurrentTimeMicros  avgt   25  25.900 ± 1.246  ns/op
NativeTimeBench.nativeCurrentTimeNanos   avgt   25  25.117 ± 1.479  ns/op
```

### See Also

Another project doing something similar:
https://github.com/caplin/nanotime

See here for more information on JavaCritical:
https://stackoverflow.com/questions/36298111/is-it-possible-to-use-sun-misc-unsafe-to-call-c-functions-without-jni/36309652#36309652

Very useful explanation of the output generated by +PrintCompilation
https://gist.github.com/rednaxelafx/1165804#file_notes.md
